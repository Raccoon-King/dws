
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">dws/api/errors.go (100.0%)</option>
				
				<option value="file1">dws/api/handlers.go (26.7%)</option>
				
				<option value="file2">dws/engine/engine.go (96.6%)</option>
				
				<option value="file3">dws/llm/analyzer.go (83.2%)</option>
				
				<option value="file4">dws/llm/bedrock_provider.go (0.0%)</option>
				
				<option value="file5">dws/llm/openai_provider.go (23.2%)</option>
				
				<option value="file6">dws/llm/service.go (95.7%)</option>
				
				<option value="file7">dws/llm/smart_analyzer.go (0.0%)</option>
				
				<option value="file8">dws/main.go (33.7%)</option>
				
				<option value="file9">dws/s3/client.go (53.8%)</option>
				
				<option value="file10">dws/scanner/extract.go (89.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "encoding/json"
        "net/http"

        "github.com/sirupsen/logrus"
)

// Error represents a structured error response.
type Error struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
}

// ErrorResponse sends a structured error response to the client and logs server errors.
func ErrorResponse(w http.ResponseWriter, code int, message string) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(code)
        json.NewEncoder(w).Encode(Error{Code: code, Message: message})

        // Log error details for server errors
        if code &gt;= 500 </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "error_code": code,
                        "error_msg":  message,
                }).Error("Server error occurred")
        }</span> else<span class="cov8" title="1"> if code &gt;= 400 </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "error_code": code,
                        "error_msg":  message,
                }).Warn("Client error occurred")
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package api

import (
        "context"
        "encoding/json"
        "io"
        "net/http"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/sirupsen/logrus"

        "dws/engine"
        "dws/llm"
        "dws/scanner"
        "dws/s3"
)

var rulesFile string
var llmAnalyzer *llm.Analyzer

// SetRulesFile sets the rules file path for the api package.
func SetRulesFile(path string) <span class="cov8" title="1">{
        rulesFile = path
}</span>

// SetLLMAnalyzer sets the LLM analyzer for the api package.
func SetLLMAnalyzer(analyzer *llm.Analyzer) <span class="cov0" title="0">{
        llmAnalyzer = analyzer
}</span>

type Report struct {
        FileID   string          `json:"fileID"`
        Findings []engine.Finding `json:"findings"`
}

// EndpointDoc represents the documentation for a single API endpoint.
type EndpointDoc struct {
        Path        string       `json:"path"`
        Method      string       `json:"method"`
        Description string       `json:"description"`
        DataShapes  []DataShape  `json:"data_shapes"`
        CurlExample string       `json:"curl_example"`
}

// DataShape represents the structure of a request or response body.
type DataShape struct {
        Name        string `json:"name"`
        Description string `json:"description"`
        Shape       string `json:"shape"`
}

// DocsHandler returns a JSON array of all available endpoints and their documentation.
func DocsHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        docs := []EndpointDoc{
                {
                        Path:        "/scan",
                        Method:      "POST",
                        Description: "Upload a document to be scanned and receive a structured report of findings including rule descriptions.",
                        DataShapes: []DataShape{
                                {
                                        Name:        "Request",
                                        Description: "multipart/form-data",
                                        Shape:       `{"file": "&lt;file&gt;"}`,
                                },
                                {
                                        Name:        "Response",
                                        Description: "A structured report of findings.",
                                        Shape:       `{"file_id":"uploaded-filename","findings":[{"rule_id":"rule-1","severity":"high","line":3,"context":"line containing match","description":"rule description"}]}`,
                                },
                        },
                        CurlExample: `curl -X POST -F 'file=@/path/to/your/file.pdf' http://localhost:8080/scan`,
                },
                {
                        Path:        "/rules/reload",
                        Method:      "POST",
                        Description: "Replace the existing rules with a new set.",
                        DataShapes: []DataShape{
                                {
                                        Name:        "Request",
                                        Description: "A JSON object containing the new rules.",
                                        Shape:       `{"rules":[{"id":"rule-1","pattern":"secret","severity":"high"}]}`,
                                },
                        },
                        CurlExample: `curl -X POST -H "Content-Type: application/json" -d '{\"rules\":[{\"id\":\"rule-1\",\"pattern\":\"secret\",\"severity\":\"high\"}]}' http://localhost:8080/rules/reload`,
                },
                {
                        Path:        "/rules/load",
                        Method:      "POST",
                        Description: "Load rules from a YAML file on disk.",
                        DataShapes: []DataShape{
                                {
                                        Name:        "Request",
                                        Description: "A JSON object containing the path to the rules file.",
                                        Shape:       `{"path":"/etc/dws/rules.yaml"}`,
                                },
                        },
                        CurlExample: `curl -X POST -H "Content-Type: application/json" -d '{\"path\":\"/etc/dws/rules.yaml\"}' http://localhost:8080/rules/load`,
                },
                {
                        Path:        "/health",
                        Method:      "GET",
                        Description: "Health check endpoint.",
                        DataShapes: []DataShape{
                                {
                                        Name:        "Response",
                                        Description: "A JSON object indicating the status of the service.",
                                        Shape:       `{"status":"ok"}`,
                                },
                        },
                        CurlExample: `curl http://localhost:8080/health`,
                },
                {
                        Path:        "/ruleset?rule",
                        Method:      "POST",
                        Description: "Scan a document against a specific ruleset specified by the 'rule' query parameter (expects rules/{rule}.yaml).",
                        DataShapes: []DataShape{
                                {
                                        Name:        "Request",
                                        Description: "multipart/form-data with 'rule' query parameter",
                                        Shape:       `{"file": "&lt;file&gt;"}`,
                                },
                                {
                                        Name:        "Response",
                                        Description: "A structured report of findings for the specified ruleset.",
                                        Shape:       `{"file_id":"uploaded-filename","findings":[{"rule_id":"rule-1","severity":"high","line":3,"context":"line containing match","description":"rule description"}]}`,
                                },
                        },
                        CurlExample: `curl -X POST -F 'file=@/path/to/your/file.pdf' 'http://localhost:8080/ruleset?rule=customrules'`,
                },
                {
                        Path:        "/scan/s3",
                        Method:      "POST",
                        Description: "Scan a document from S3 URL. Supports IAM roles and access key authentication.",
                        DataShapes: []DataShape{
                                {
                                        Name:        "Request",
                                        Description: "JSON object with S3 URL and optional authentication parameters",
                                        Shape:       `{"s3_url":"s3://bucket/path/file.pdf","region":"us-east-1","access_key_id":"optional","secret_access_key":"optional","session_token":"optional","role_arn":"optional"}`,
                                },
                                {
                                        Name:        "Response",
                                        Description: "A structured report of findings from the S3 file.",
                                        Shape:       `{"file_id":"file.pdf","findings":[{"rule_id":"rule-1","severity":"high","line":3,"context":"line containing match","description":"rule description"}]}`,
                                },
                        },
                        CurlExample: `curl -X POST -H "Content-Type: application/json" -d '{"s3_url":"s3://my-bucket/document.pdf","region":"us-west-2"}' http://localhost:8080/scan/s3`,
                },
                {
                        Path:        "/scan/llm",
                        Method:      "POST",
                        Description: "Upload a document for LLM-powered analysis with semantic understanding.",
                        DataShapes: []DataShape{
                                {
                                        Name:        "Request",
                                        Description: "multipart/form-data with optional analysis rules",
                                        Shape:       `{"file": "&lt;file&gt;", "rules": ["optional custom rules"]}`,
                                },
                                {
                                        Name:        "Response",
                                        Description: "LLM analysis results with confidence scores and reasoning.",
                                        Shape:       `{"file_id":"uploaded-filename","findings":[{"rule_id":"llm-finding-1","severity":"high","line":3,"context":"matching text","description":"finding description","confidence":0.9,"reasoning":"why this is a finding"}],"summary":"overall analysis","confidence":0.8,"tokens_used":150,"model":"gpt-3.5-turbo","provider":"openai"}`,
                                },
                        },
                        CurlExample: `curl -X POST -F 'file=@/path/to/your/file.pdf' -F 'rules=["Look for API keys","Check for PII"]' http://localhost:8080/scan/llm`,
                },
                {
                        Path:        "/scan/hybrid",
                        Method:      "POST",
                        Description: "Upload a document for hybrid analysis combining regex rules with LLM validation.",
                        DataShapes: []DataShape{
                                {
                                        Name:        "Request",
                                        Description: "multipart/form-data",
                                        Shape:       `{"file": "&lt;file&gt;"}`,
                                },
                                {
                                        Name:        "Response",
                                        Description: "Combined analysis with validated findings and LLM insights.",
                                        Shape:       `{"file_id":"uploaded-filename","regex_findings":[...],"llm_analysis":{...},"validated_findings":[...],"tokens_used":150}`,
                                },
                        },
                        CurlExample: `curl -X POST -F 'file=@/path/to/your/file.pdf' http://localhost:8080/scan/hybrid`,
                },
                {
                        Path:        "/docs",
                        Method:      "GET",
                        Description: "Returns a JSON array of all available endpoints and their documentation.",
                        CurlExample: `curl http://localhost:8080/docs`,
                },
        }

        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(docs)
}</span>

// RulesetHandler handles scanning a document against a specific ruleset.
func RulesetHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        rule := r.URL.Query().Get("rule")
        if rule == "" </span><span class="cov8" title="1">{
                ErrorResponse(w, http.StatusBadRequest, "missing rule query parameter")
                return
        }</span>
        // Prevent path traversal attacks by ensuring rule doesn't contain invalid characters
        <span class="cov8" title="1">if strings.ContainsAny(rule, "/\\..") </span><span class="cov8" title="1">{
                ErrorResponse(w, http.StatusBadRequest, "invalid rule name")
                return
        }</span>

        <span class="cov8" title="1">path := "rules/" + rule + ".yaml"

        rules, err := engine.LoadRulesFromFile(path)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "file":  path,
                        "error": err,
                }).Error("Failed to load ruleset from file")
                ErrorResponse(w, http.StatusInternalServerError, "failed to load ruleset")
                return
        }</span>

        <span class="cov8" title="1">if err := r.ParseMultipartForm(10 &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "invalid multipart")
                return
        }</span>
        <span class="cov8" title="1">file, header, err := r.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "missing file")
                return
        }</span>
        <span class="cov8" title="1">defer file.Close()
        data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusInternalServerError, "read error")
                return
        }</span>
        <span class="cov8" title="1">text, err := scanner.ExtractText(data, header.Filename)
        if err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "unsupported file")
                return
        }</span>
        <span class="cov8" title="1">findings := engine.Evaluate(text, header.Filename, rules)
        // Debug mode is available via engine.GetDebugMode if implemented
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(Report{FileID: header.Filename, Findings: findings})</span>
}

// ScanHandler ingests text and returns findings.
func ScanHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if err := r.ParseMultipartForm(10 &lt;&lt; 20); err != nil </span><span class="cov8" title="1">{
                ErrorResponse(w, http.StatusBadRequest, "invalid multipart")
                return
        }</span>
        <span class="cov8" title="1">file, header, err := r.FormFile("file")
        if err != nil </span><span class="cov8" title="1">{
                ErrorResponse(w, http.StatusBadRequest, "missing file")
                return
        }</span>
        <span class="cov8" title="1">defer file.Close()
        data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusInternalServerError, "read error")
                return
        }</span>
        <span class="cov8" title="1">text, err := scanner.ExtractText(data, header.Filename)
        if err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "unsupported file")
                return
        }</span>
        <span class="cov8" title="1">findings := engine.Evaluate(text, header.Filename, engine.GetRules())
        if engine.GetDebugMode() </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "file_id":  header.Filename,
                        "findings": findings,
                }).Debug("Findings before encoding")
        }</span>
        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(Report{FileID: header.Filename, Findings: findings})</span>
}

// ReloadRulesHandler replaces the current rule set.
func ReloadRulesHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        type request struct {
                Rules []engine.Rule `json:"rules"`
        }
        var req request
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "invalid request")
                return
        }</span>

        <span class="cov8" title="1">for i := range req.Rules </span><span class="cov8" title="1">{
                _, err := regexp.Compile(req.Rules[i].Pattern)
                if err != nil </span><span class="cov8" title="1">{
                        ErrorResponse(w, http.StatusBadRequest, fmt.Sprintf("failed to compile regex for rule %s: %v", req.Rules[i].ID, err))
                        return
                }</span>
        }

        <span class="cov8" title="1">engine.SetRules(req.Rules)
        w.WriteHeader(http.StatusOK)</span>
}

// LoadRulesFromFileHandler loads rules from a file specified in the request body.
func LoadRulesFromFileHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        type request struct {
                Path string `json:"path"`
        }
        var req request
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "invalid request")
                return
        }</span>

        <span class="cov8" title="1">if req.Path == "" </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "missing path parameter")
                return
        }</span>

        // Clean the path to prevent path traversal attacks.
        <span class="cov8" title="1">path := filepath.Clean(req.Path)
        if strings.HasPrefix(path, "..") </span><span class="cov8" title="1">{
                ErrorResponse(w, http.StatusBadRequest, "invalid path")
                return
        }</span>

        <span class="cov8" title="1">if err := engine.LoadRulesFromYAML(path); err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "file":  path,
                        "error": err,
                }).Error("Failed to load rules from YAML file")
                ErrorResponse(w, http.StatusInternalServerError, "failed to load rules file")
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(map[string]string{"status": "rules loaded successfully"})</span>
}

// S3ScanRequest represents a request to scan a file from S3
type S3ScanRequest struct {
        S3URL           string `json:"s3_url"`
        Region          string `json:"region,omitempty"`
        AccessKeyID     string `json:"access_key_id,omitempty"`
        SecretAccessKey string `json:"secret_access_key,omitempty"`
        SessionToken    string `json:"session_token,omitempty"`
        RoleARN         string `json:"role_arn,omitempty"`
}

// S3ScanHandler processes documents from S3 URLs
func S3ScanHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req S3ScanRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if req.S3URL == "" </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "missing s3_url parameter")
                return
        }</span>

        // Set default region if not provided
        <span class="cov0" title="0">if req.Region == "" </span><span class="cov0" title="0">{
                req.Region = "us-east-1"
        }</span>

        // Create S3 client configuration
        <span class="cov0" title="0">config := s3.Config{
                Region:          req.Region,
                AccessKeyID:     req.AccessKeyID,
                SecretAccessKey: req.SecretAccessKey,
                SessionToken:    req.SessionToken,
                RoleARN:         req.RoleARN,
                Timeout:         30 * time.Second,
        }

        client, err := s3.NewClient(config)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "s3_url": req.S3URL,
                        "error":  err,
                }).Error("Failed to create S3 client")
                ErrorResponse(w, http.StatusInternalServerError, "failed to create S3 client")
                return
        }</span>

        // Create context with timeout for the entire operation
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()

        // Download file from S3 with detailed error handling
        data, filename, err := client.DownloadFileFromURL(ctx, req.S3URL)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "s3_url": req.S3URL,
                        "error":  err,
                }).Error("Failed to download file from S3")

                // Check for specific error types
                if ctx.Err() == context.DeadlineExceeded </span><span class="cov0" title="0">{
                        ErrorResponse(w, http.StatusRequestTimeout, "download timeout: file took too long to download from S3")
                        return
                }</span>

                // Check for AWS-specific errors
                <span class="cov0" title="0">if err.Error() == "NoSuchBucket" || strings.Contains(err.Error(), "NoSuchBucket") </span><span class="cov0" title="0">{
                        ErrorResponse(w, http.StatusNotFound, "S3 bucket not found")
                        return
                }</span>
                <span class="cov0" title="0">if err.Error() == "NoSuchKey" || strings.Contains(err.Error(), "NoSuchKey") </span><span class="cov0" title="0">{
                        ErrorResponse(w, http.StatusNotFound, "S3 file not found")
                        return
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "AccessDenied") </span><span class="cov0" title="0">{
                        ErrorResponse(w, http.StatusForbidden, "access denied: check S3 permissions")
                        return
                }</span>
                <span class="cov0" title="0">if strings.Contains(err.Error(), "invalid S3 URL") </span><span class="cov0" title="0">{
                        ErrorResponse(w, http.StatusBadRequest, "invalid S3 URL format")
                        return
                }</span>

                <span class="cov0" title="0">ErrorResponse(w, http.StatusInternalServerError, "failed to download file from S3")
                return</span>
        }

        // Check file size limits (10MB max)
        <span class="cov0" title="0">const maxFileSize = 10 &lt;&lt; 20 // 10 MB
        if len(data) &gt; maxFileSize </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "s3_url":   req.S3URL,
                        "filename": filename,
                        "size":     len(data),
                        "max_size": maxFileSize,
                }).Warn("File size exceeds maximum allowed")
                ErrorResponse(w, http.StatusRequestEntityTooLarge, "file size exceeds 10MB limit")
                return
        }</span>

        // Extract text from the downloaded file with timeout protection
        <span class="cov0" title="0">text, err := scanner.ExtractText(data, filename)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "s3_url":   req.S3URL,
                        "filename": filename,
                        "error":    err,
                }).Error("Failed to extract text from S3 file")

                if strings.Contains(err.Error(), "unsupported file format") </span><span class="cov0" title="0">{
                        ErrorResponse(w, http.StatusUnsupportedMediaType, fmt.Sprintf("unsupported file format: %s", err.Error()))
                        return
                }</span>

                <span class="cov0" title="0">ErrorResponse(w, http.StatusInternalServerError, "failed to extract text from file")
                return</span>
        }

        // Process the text with the scanning engine
        <span class="cov0" title="0">findings := engine.Evaluate(text, filename, engine.GetRules())

        if engine.GetDebugMode() </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "s3_url":   req.S3URL,
                        "filename": filename,
                        "findings": findings,
                }).Debug("S3 scan findings before encoding")
        }</span>

        // Return the results
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(Report{FileID: filename, Findings: findings})</span>
}

// HealthHandler reports service health.
func HealthHandler(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        // Check if the rules file is readable
        if _, err := os.Stat(rulesFile); err != nil </span><span class="cov8" title="1">{
                ErrorResponse(w, http.StatusServiceUnavailable, "rules file not readable")
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")
        w.Write([]byte(`{"status":"ok"}`))</span>
}

// LLMScanHandler performs document analysis using LLM
func LLMScanHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if llmAnalyzer == nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusServiceUnavailable, "LLM service is not available")
                return
        }</span>

        <span class="cov0" title="0">if err := r.ParseMultipartForm(10 &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "invalid multipart")
                return
        }</span>

        <span class="cov0" title="0">file, header, err := r.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "missing file")
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusInternalServerError, "read error")
                return
        }</span>

        <span class="cov0" title="0">text, err := scanner.ExtractText(data, header.Filename)
        if err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "unsupported file")
                return
        }</span>

        // Parse optional custom rules
        <span class="cov0" title="0">var customRules []string
        if rulesParam := r.FormValue("rules"); rulesParam != "" </span><span class="cov0" title="0">{
                if err := json.Unmarshal([]byte(rulesParam), &amp;customRules); err != nil </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "rules_param": rulesParam,
                                "error":       err,
                        }).Warn("Failed to parse custom rules, using defaults")
                }</span>
        }

        // Create analysis request
        <span class="cov0" title="0">analysisReq := llm.AnalysisRequest{
                Text:     text,
                Filename: header.Filename,
                Rules:    customRules,
        }

        // Create context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
        defer cancel()

        // Perform LLM analysis
        analysisResp, err := llmAnalyzer.AnalyzeDocument(ctx, analysisReq)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "filename": header.Filename,
                        "error":    err,
                }).Error("LLM analysis failed")
                ErrorResponse(w, http.StatusInternalServerError, "LLM analysis failed")
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(analysisResp)</span>
}

// HybridScanHandler performs both regex and LLM analysis
func HybridScanHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if err := r.ParseMultipartForm(10 &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "invalid multipart")
                return
        }</span>

        <span class="cov0" title="0">file, header, err := r.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "missing file")
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusInternalServerError, "read error")
                return
        }</span>

        <span class="cov0" title="0">text, err := scanner.ExtractText(data, header.Filename)
        if err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "unsupported file")
                return
        }</span>

        // Perform regex analysis first
        <span class="cov0" title="0">regexFindings := engine.Evaluate(text, header.Filename, engine.GetRules())

        // Create response object
        response := map[string]interface{}{
                "file_id":        header.Filename,
                "regex_findings": regexFindings,
        }

        // Perform LLM analysis if available
        if llmAnalyzer != nil </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 2*time.Minute)
                defer cancel()

                // LLM analysis
                analysisReq := llm.AnalysisRequest{
                        Text:     text,
                        Filename: header.Filename,
                }

                llmAnalysis, err := llmAnalyzer.AnalyzeDocument(ctx, analysisReq)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "filename": header.Filename,
                                "error":    err,
                        }).Warn("LLM analysis failed in hybrid mode")
                }</span> else<span class="cov0" title="0"> {
                        response["llm_analysis"] = llmAnalysis
                }</span>

                // Validate regex findings with LLM
                <span class="cov0" title="0">validatedFindings, err := llmAnalyzer.ValidateFindings(ctx, regexFindings, text, header.Filename)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "filename": header.Filename,
                                "error":    err,
                        }).Warn("LLM validation failed in hybrid mode")
                        response["validated_findings"] = regexFindings // Use original if validation fails
                }</span> else<span class="cov0" title="0"> {
                        response["validated_findings"] = validatedFindings
                }</span>

                <span class="cov0" title="0">if llmAnalysis != nil </span><span class="cov0" title="0">{
                        response["tokens_used"] = llmAnalysis.TokensUsed
                }</span>
        } else<span class="cov0" title="0"> {
                response["validated_findings"] = regexFindings
                response["llm_analysis"] = nil
                response["tokens_used"] = 0
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)</span>
}

// SmartScanHandler performs optimized analysis using rules as pre-filters
func SmartScanHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if err := r.ParseMultipartForm(10 &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "invalid multipart")
                return
        }</span>

        <span class="cov0" title="0">file, header, err := r.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "missing file")
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        data, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusInternalServerError, "read error")
                return
        }</span>

        <span class="cov0" title="0">text, err := scanner.ExtractText(data, header.Filename)
        if err != nil </span><span class="cov0" title="0">{
                ErrorResponse(w, http.StatusBadRequest, "unsupported file")
                return
        }</span>

        // Smart pre-filtering analysis
        <span class="cov0" title="0">if llmAnalyzer != nil </span><span class="cov0" title="0">{
                // Create smart analyzer with cost optimization
                smartConfig := llm.SmartAnalysisConfig{
                        MinFindingsThreshold: 2,
                        TriggerSeverities:    []string{"high", "medium"},
                        MinDocumentLength:    200,
                        MaxDocumentLength:    4000,
                        AnalyzeRuleTypes:     []string{"disease", "aggressive", "property"},
                }

                smartAnalyzer := llm.NewSmartAnalyzer(llmAnalyzer, smartConfig)

                ctx, cancel := context.WithTimeout(context.Background(), 90*time.Second)
                defer cancel()

                result, err := smartAnalyzer.AnalyzeWithPrefiltering(ctx, text, header.Filename, engine.GetRules())
                if err != nil </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "filename": header.Filename,
                                "error":    err,
                        }).Error("Smart analysis failed")
                        ErrorResponse(w, http.StatusInternalServerError, "smart analysis failed")
                        return
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(result)</span>
        } else<span class="cov0" title="0"> {
                // Fallback to regex-only
                regexFindings := engine.Evaluate(text, header.Filename, engine.GetRules())
                response := map[string]interface{}{
                        "regex_findings":     regexFindings,
                        "llm_used":          false,
                        "validated_findings": regexFindings,
                        "tokens_used":       0,
                        "cost_savings":      "100% - LLM disabled",
                        "analysis_reason":   "LLM service not available",
                }

                w.Header().Set("Content-Type", "application/json")
                json.NewEncoder(w).Encode(response)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package engine

import (
        "io/ioutil"
        "regexp"
        "strings"

        "gopkg.in/yaml.v3"

        "github.com/sirupsen/logrus"
)

// Rule defines a pattern that will be searched in text.
type Rule struct {
        ID       string `json:"id"`
        Pattern  string `json:"pattern"`
        Severity string `json:"severity"`
        Description string `json:"description"`
}

// RulesConfig represents the YAML structure for rules configuration
type RulesConfig struct {
        Rules []Rule `json:"rules" yaml:"rules"`
}

// Finding represents a rule match inside a document.
type Finding struct {
        FileID      string `json:"file_id"`
        RuleID      string `json:"rule_id"`
        Severity    string `json:"severity"`
        Line        int    `json:"line"`
        Context     string `json:"context"`
        Description string `json:"description"`
}

var currentRules []Rule
var debugMode bool

// SetRules replaces the in-memory rule set.
func SetRules(rules []Rule) <span class="cov8" title="1">{
        currentRules = rules
}</span>

// LoadRulesFromFile loads rules from a YAML file without setting them globally.
func LoadRulesFromFile(path string) ([]Rule, error) <span class="cov8" title="1">{
        data, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "file":  path,
                        "error": err,
                }).Error("Failed to read rules file")
                return []Rule{}, err
        }</span>
        <span class="cov8" title="1">var config RulesConfig
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "file":     path,
                        "error":    err,
                        "yaml_data": string(data),
                }).Error("Failed to unmarshal YAML rules file")
                return []Rule{}, err
        }</span>
        <span class="cov8" title="1">return config.Rules, nil</span>
}

// GetRules returns the current in-memory rule set.
func GetRules() []Rule <span class="cov8" title="1">{
        return currentRules
}</span>

// Evaluate scans the provided text and returns findings for the current rules.
func Evaluate(text, fileID string, rules []Rule) []Finding <span class="cov8" title="1">{
        var findings []Finding
        lines := strings.Split(text, "\n")
        for i, line := range lines </span><span class="cov8" title="1">{
                for _, rule := range rules </span><span class="cov8" title="1">{
                        re, err := regexp.Compile(rule.Pattern)
                        if err != nil </span><span class="cov8" title="1">{
                                logrus.WithFields(logrus.Fields{
                                        "rule_id":  rule.ID,
                                        "pattern":  rule.Pattern,
                                        "error":    err,
                                }).Warn("Failed to compile regex for rule")
                                continue</span>
                        }
                        <span class="cov8" title="1">if re.MatchString(line) </span><span class="cov8" title="1">{
                                findings = append(findings, Finding{
                                        FileID:      fileID,
                                        RuleID:      rule.ID,
                                        Severity:    rule.Severity,
                                        Line:        i + 1,
                                        Context:     line,
                                        Description: rule.Description,
                                })
                        }</span>
                }
        }
        <span class="cov8" title="1">return findings</span>
}

// LoadRulesFromYAML loads rules from a YAML file and sets them globally.
// This is called during initialization.
func LoadRulesFromYAML(path string) error <span class="cov8" title="1">{
        rules, err := LoadRulesFromFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">SetRules(rules)
        return nil</span>
}

// SetDebugMode sets the debug mode for the engine.
func SetDebugMode(debug bool) <span class="cov8" title="1">{
        debugMode = debug
}</span>

// GetDebugMode returns the current debug mode.
func GetDebugMode() bool <span class="cov8" title="1">{
        return debugMode
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package llm

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/sirupsen/logrus"

        "dws/engine"
)

// LLMService interface for dependency injection in tests
type LLMService interface {
        Complete(ctx context.Context, prompt string) (*CompletionResponse, error)
        IsEnabled() bool
}

// Analyzer provides LLM-powered document analysis capabilities
type Analyzer struct {
        service LLMService
}

// NewAnalyzer creates a new LLM analyzer
func NewAnalyzer(service LLMService) *Analyzer <span class="cov8" title="1">{
        return &amp;Analyzer{
                service: service,
        }
}</span>

// AnalysisRequest represents a request for LLM-based document analysis
type AnalysisRequest struct {
        Text     string   `json:"text"`
        Filename string   `json:"filename"`
        Rules    []string `json:"rules,omitempty"`    // Optional rule descriptions
        Context  string   `json:"context,omitempty"`  // Optional context about the document
}

// AnalysisResponse represents the response from LLM analysis
type AnalysisResponse struct {
        Findings     []LLMFinding `json:"findings"`
        Summary      string       `json:"summary,omitempty"`
        Confidence   float32      `json:"confidence"`
        TokensUsed   int          `json:"tokens_used"`
        Model        string       `json:"model"`
        Provider     Provider     `json:"provider"`
}

// LLMFinding represents a finding from LLM analysis
type LLMFinding struct {
        RuleID      string  `json:"rule_id"`
        Severity    string  `json:"severity"`
        Line        int     `json:"line"`
        Context     string  `json:"context"`
        Description string  `json:"description"`
        Confidence  float32 `json:"confidence"`
        Reasoning   string  `json:"reasoning,omitempty"`
}

// AnalyzeDocument performs comprehensive document analysis using LLM
func (a *Analyzer) AnalyzeDocument(ctx context.Context, req AnalysisRequest) (*AnalysisResponse, error) <span class="cov8" title="1">{
        if !a.service.IsEnabled() </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("LLM service is not enabled")
        }</span>

        <span class="cov8" title="1">prompt := a.buildAnalysisPrompt(req)

        response, err := a.service.Complete(ctx, prompt)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LLM analysis failed: %w", err)
        }</span>

        // Parse the LLM response
        <span class="cov8" title="1">analysisResp, err := a.parseAnalysisResponse(response.Text, req.Filename)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "filename": req.Filename,
                        "error":    err,
                        "response": response.Text,
                }).Warn("Failed to parse LLM analysis response, returning raw analysis")

                // Fallback: return a single finding with the raw analysis
                analysisResp = &amp;AnalysisResponse{
                        Findings: []LLMFinding{
                                {
                                        RuleID:      "llm-analysis",
                                        Severity:    "info",
                                        Line:        1,
                                        Context:     truncateString(req.Text, 200),
                                        Description: "LLM document analysis",
                                        Confidence:  0.5,
                                        Reasoning:   response.Text,
                                },
                        },
                        Summary:    response.Text,
                        Confidence: 0.5,
                }
        }</span>

        <span class="cov8" title="1">analysisResp.TokensUsed = response.TokensUsed
        analysisResp.Model = response.Model
        analysisResp.Provider = response.Provider

        return analysisResp, nil</span>
}

// ValidateFindings compares regex findings with LLM analysis to reduce false positives
func (a *Analyzer) ValidateFindings(ctx context.Context, findings []engine.Finding, text string, filename string) ([]engine.Finding, error) <span class="cov8" title="1">{
        if !a.service.IsEnabled() || len(findings) == 0 </span><span class="cov0" title="0">{
                return findings, nil
        }</span>

        <span class="cov8" title="1">prompt := a.buildValidationPrompt(findings, text, filename)

        response, err := a.service.Complete(ctx, prompt)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "filename": filename,
                        "error":    err,
                }).Warn("LLM validation failed, returning original findings")
                return findings, nil
        }</span>

        // Parse validation response
        <span class="cov8" title="1">validatedFindings, err := a.parseValidationResponse(response.Text, findings)
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "filename": filename,
                        "error":    err,
                }).Warn("Failed to parse validation response, returning original findings")
                return findings, nil
        }</span>

        <span class="cov8" title="1">return validatedFindings, nil</span>
}

// buildAnalysisPrompt creates a prompt for document analysis
func (a *Analyzer) buildAnalysisPrompt(req AnalysisRequest) string <span class="cov8" title="1">{
        var sb strings.Builder

        sb.WriteString("You are a security analyst reviewing documents for sensitive information and policy violations.\n\n")

        if req.Context != "" </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("Document context: %s\n\n", req.Context))
        }</span>

        <span class="cov8" title="1">sb.WriteString("Please analyze the following document and identify any findings. ")
        sb.WriteString("Return your analysis as a JSON object with this exact structure:\n")
        sb.WriteString("{\n")
        sb.WriteString("  \"findings\": [\n")
        sb.WriteString("    {\n")
        sb.WriteString("      \"rule_id\": \"unique_identifier\",\n")
        sb.WriteString("      \"severity\": \"high|medium|low\",\n")
        sb.WriteString("      \"line\": line_number,\n")
        sb.WriteString("      \"context\": \"the_matching_text\",\n")
        sb.WriteString("      \"description\": \"what_was_found\",\n")
        sb.WriteString("      \"confidence\": 0.0_to_1.0,\n")
        sb.WriteString("      \"reasoning\": \"why_this_is_a_finding\"\n")
        sb.WriteString("    }\n")
        sb.WriteString("  ],\n")
        sb.WriteString("  \"summary\": \"brief_overall_assessment\",\n")
        sb.WriteString("  \"confidence\": 0.0_to_1.0\n")
        sb.WriteString("}\n\n")

        if len(req.Rules) &gt; 0 </span><span class="cov8" title="1">{
                sb.WriteString("Focus on these specific areas:\n")
                for i, rule := range req.Rules </span><span class="cov8" title="1">{
                        sb.WriteString(fmt.Sprintf("%d. %s\n", i+1, rule))
                }</span>
                <span class="cov8" title="1">sb.WriteString("\n")</span>
        } else<span class="cov0" title="0"> {
                sb.WriteString("Look for:\n")
                sb.WriteString("- Personally identifiable information (PII)\n")
                sb.WriteString("- Credit card numbers, SSNs, phone numbers\n")
                sb.WriteString("- API keys, passwords, tokens\n")
                sb.WriteString("- Confidential or sensitive business information\n")
                sb.WriteString("- Compliance violations\n\n")
        }</span>

        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("Document to analyze (%s):\n", req.Filename))
        sb.WriteString("---\n")
        sb.WriteString(truncateString(req.Text, 8000)) // Limit text to avoid token limits
        sb.WriteString("\n---\n\n")
        sb.WriteString("Provide your analysis as valid JSON:")

        return sb.String()</span>
}

// buildValidationPrompt creates a prompt for validating existing findings
func (a *Analyzer) buildValidationPrompt(findings []engine.Finding, text string, filename string) string <span class="cov8" title="1">{
        var sb strings.Builder

        sb.WriteString("You are validating security findings from an automated scanner. ")
        sb.WriteString("Review each finding and determine if it's a true positive or false positive.\n\n")

        sb.WriteString("Return a JSON array of finding IDs that should be KEPT (true positives):\n")
        sb.WriteString("{ \"valid_findings\": [\"finding_1\", \"finding_2\"] }\n\n")

        sb.WriteString("Original findings to validate:\n")
        for i, finding := range findings </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("%d. ID: finding_%d, Rule: %s, Severity: %s, Line: %d, Context: %s\n",
                        i+1, i, finding.RuleID, finding.Severity, finding.Line, finding.Context))
        }</span>

        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("\nDocument context (%s):\n", filename))
        sb.WriteString("---\n")
        sb.WriteString(truncateString(text, 4000))
        sb.WriteString("\n---\n\n")
        sb.WriteString("Return JSON with valid finding IDs:")

        return sb.String()</span>
}

// parseAnalysisResponse parses the LLM analysis response
func (a *Analyzer) parseAnalysisResponse(responseText, filename string) (*AnalysisResponse, error) <span class="cov8" title="1">{
        // Try to extract JSON from the response
        jsonStr := extractJSON(responseText)
        if jsonStr == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no JSON found in response")
        }</span>

        <span class="cov8" title="1">var resp AnalysisResponse
        if err := json.Unmarshal([]byte(jsonStr), &amp;resp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON: %w", err)
        }</span>

        // Validate and set defaults
        <span class="cov8" title="1">for i := range resp.Findings </span><span class="cov8" title="1">{
                if resp.Findings[i].RuleID == "" </span><span class="cov0" title="0">{
                        resp.Findings[i].RuleID = fmt.Sprintf("llm-finding-%d", i+1)
                }</span>
                <span class="cov8" title="1">if resp.Findings[i].Severity == "" </span><span class="cov0" title="0">{
                        resp.Findings[i].Severity = "medium"
                }</span>
                <span class="cov8" title="1">if resp.Findings[i].Line &lt;= 0 </span><span class="cov0" title="0">{
                        resp.Findings[i].Line = 1
                }</span>
                <span class="cov8" title="1">if resp.Findings[i].Confidence &lt;= 0 </span><span class="cov0" title="0">{
                        resp.Findings[i].Confidence = 0.7
                }</span>
        }

        <span class="cov8" title="1">if resp.Confidence &lt;= 0 </span><span class="cov0" title="0">{
                resp.Confidence = 0.7
        }</span>

        <span class="cov8" title="1">return &amp;resp, nil</span>
}

// parseValidationResponse parses the validation response
func (a *Analyzer) parseValidationResponse(responseText string, originalFindings []engine.Finding) ([]engine.Finding, error) <span class="cov8" title="1">{
        jsonStr := extractJSON(responseText)
        if jsonStr == "" </span><span class="cov0" title="0">{
                return originalFindings, fmt.Errorf("no JSON found in validation response")
        }</span>

        <span class="cov8" title="1">var validationResp struct {
                ValidFindings []string `json:"valid_findings"`
        }

        if err := json.Unmarshal([]byte(jsonStr), &amp;validationResp); err != nil </span><span class="cov0" title="0">{
                return originalFindings, fmt.Errorf("failed to unmarshal validation JSON: %w", err)
        }</span>

        // Create map of valid finding IDs
        <span class="cov8" title="1">validMap := make(map[string]bool)
        for _, id := range validationResp.ValidFindings </span><span class="cov8" title="1">{
                validMap[id] = true
        }</span>

        // Filter findings
        <span class="cov8" title="1">var validatedFindings []engine.Finding
        for i, finding := range originalFindings </span><span class="cov8" title="1">{
                findingID := fmt.Sprintf("finding_%d", i)
                if validMap[findingID] </span><span class="cov8" title="1">{
                        validatedFindings = append(validatedFindings, finding)
                }</span>
        }

        <span class="cov8" title="1">return validatedFindings, nil</span>
}

// extractJSON attempts to extract JSON from a text response
func extractJSON(text string) string <span class="cov8" title="1">{
        // Look for JSON object or array
        start := strings.Index(text, "{")
        if start == -1 </span><span class="cov8" title="1">{
                start = strings.Index(text, "[")
        }</span>
        <span class="cov8" title="1">if start == -1 </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Find the matching closing brace/bracket
        <span class="cov8" title="1">var end int
        openChar := text[start]
        var closeChar byte
        if openChar == '{' </span><span class="cov8" title="1">{
                closeChar = '}'
        }</span> else<span class="cov0" title="0"> {
                closeChar = ']'
        }</span>

        <span class="cov8" title="1">depth := 0
        for i := start; i &lt; len(text); i++ </span><span class="cov8" title="1">{
                if text[i] == openChar </span><span class="cov8" title="1">{
                        depth++
                }</span> else<span class="cov8" title="1"> if text[i] == closeChar </span><span class="cov8" title="1">{
                        depth--
                        if depth == 0 </span><span class="cov8" title="1">{
                                end = i + 1
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if end == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">return text[start:end]</span>
}

// truncateString truncates a string to a maximum length
func truncateString(s string, maxLen int) string <span class="cov8" title="1">{
        if len(s) &lt;= maxLen </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return s[:maxLen] + "... [truncated]"</span>
}

// ConvertLLMFindingsToEngine converts LLM findings to engine findings
func ConvertLLMFindingsToEngine(llmFindings []LLMFinding, fileID string) []engine.Finding <span class="cov8" title="1">{
        var findings []engine.Finding

        for _, llmFinding := range llmFindings </span><span class="cov8" title="1">{
                finding := engine.Finding{
                        FileID:   fileID,
                        RuleID:   llmFinding.RuleID,
                        Severity: llmFinding.Severity,
                        Line:     llmFinding.Line,
                        Context:  llmFinding.Context,
                }
                findings = append(findings, finding)
        }</span>

        <span class="cov8" title="1">return findings</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package llm

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/credentials/stscreds"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/bedrockruntime"
        "github.com/sirupsen/logrus"
)

// BedrockProvider implements LLMProvider for Amazon Bedrock
type BedrockProvider struct {
        config         BedrockConfig
        bedrockClient  *bedrockruntime.BedrockRuntime
        modelHandler   BedrockModelHandler
}

// BedrockModelHandler interface for different model families
type BedrockModelHandler interface {
        PrepareRequest(prompt string, maxTokens int, temperature float32) ([]byte, error)
        ParseResponse(response []byte) (string, int, error)
        GetModelFamily() string
}

// Claude3Handler handles Anthropic Claude models
type Claude3Handler struct{}

// Titan/J2Handler handles Amazon Titan and AI21 Jurassic models
type TitanHandler struct{}

// LlamaHandler handles Meta Llama models
type LlamaHandler struct{}

// Claude3Request represents the request format for Claude models
type Claude3Request struct {
        Messages    []Claude3Message `json:"messages"`
        MaxTokens   int              `json:"max_tokens"`
        Temperature float32          `json:"temperature,omitempty"`
        System      string           `json:"system,omitempty"`
}

type Claude3Message struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

// Claude3Response represents the response from Claude models
type Claude3Response struct {
        Content []struct {
                Type string `json:"type"`
                Text string `json:"text"`
        } `json:"content"`
        Usage struct {
                InputTokens  int `json:"input_tokens"`
                OutputTokens int `json:"output_tokens"`
        } `json:"usage"`
}

// TitanRequest represents the request format for Titan models
type TitanRequest struct {
        InputText       string              `json:"inputText"`
        TextGenerationConfig TitanGenConfig `json:"textGenerationConfig"`
}

type TitanGenConfig struct {
        MaxTokenCount int     `json:"maxTokenCount"`
        Temperature   float32 `json:"temperature"`
        TopP          float32 `json:"topP"`
}

// TitanResponse represents the response from Titan models
type TitanResponse struct {
        Results []struct {
                TokenCount       int    `json:"tokenCount"`
                OutputText       string `json:"outputText"`
                CompletionReason string `json:"completionReason"`
        } `json:"results"`
        InputTextTokenCount int `json:"inputTextTokenCount"`
}

// LlamaRequest represents the request format for Llama models
type LlamaRequest struct {
        Prompt      string  `json:"prompt"`
        MaxGenLen   int     `json:"max_gen_len"`
        Temperature float32 `json:"temperature"`
}

// LlamaResponse represents the response from Llama models
type LlamaResponse struct {
        Generation           string `json:"generation"`
        PromptTokenCount     int    `json:"prompt_token_count"`
        GenerationTokenCount int    `json:"generation_token_count"`
}

// NewBedrockProvider creates a new Amazon Bedrock provider
func NewBedrockProvider(config BedrockConfig) (*BedrockProvider, error) <span class="cov0" title="0">{
        if config.Region == "" </span><span class="cov0" title="0">{
                config.Region = "us-east-1" // Default region
        }</span>

        <span class="cov0" title="0">if config.ModelID == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("model ID is required for Bedrock provider")
        }</span>

        // Configure AWS session
        <span class="cov0" title="0">awsConfig := &amp;aws.Config{
                Region:     aws.String(config.Region),
                HTTPClient: &amp;http.Client{Timeout: 60 * time.Second},
                MaxRetries: aws.Int(3),
        }

        var sess *session.Session
        var err error

        // Configure credentials
        if config.RoleARN != "" </span><span class="cov0" title="0">{
                // Use IAM role
                sess, err = session.NewSession(awsConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create AWS session: %w", err)
                }</span>
                <span class="cov0" title="0">creds := stscreds.NewCredentials(sess, config.RoleARN)
                awsConfig.Credentials = creds</span>
        } else<span class="cov0" title="0"> if config.AccessKeyID != "" &amp;&amp; config.SecretAccessKey != "" </span><span class="cov0" title="0">{
                // Use access keys
                creds := credentials.NewStaticCredentials(config.AccessKeyID, config.SecretAccessKey, config.SessionToken)
                awsConfig.Credentials = creds
        }</span>
        // If neither is provided, it will use the default credential chain

        <span class="cov0" title="0">sess, err = session.NewSession(awsConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create AWS session: %w", err)
        }</span>

        <span class="cov0" title="0">bedrockClient := bedrockruntime.New(sess)

        // Determine model handler based on model ID
        modelHandler, err := getModelHandler(config.ModelID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unsupported model: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;BedrockProvider{
                config:         config,
                bedrockClient:  bedrockClient,
                modelHandler:   modelHandler,
        }, nil</span>
}

// Complete implements the LLMProvider interface
func (p *BedrockProvider) Complete(ctx context.Context, req CompletionRequest) (*CompletionResponse, error) <span class="cov0" title="0">{
        // Prepare request body using appropriate model handler
        requestBody, err := p.modelHandler.PrepareRequest(req.Prompt, req.MaxTokens, req.Temperature)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to prepare request: %w", err)
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "model_id":     p.config.ModelID,
                "model_family": p.modelHandler.GetModelFamily(),
                "region":       p.config.Region,
                "prompt_len":   len(req.Prompt),
        }).Debug("Sending request to Amazon Bedrock")

        // Call Bedrock
        input := &amp;bedrockruntime.InvokeModelInput{
                ModelId:     aws.String(p.config.ModelID),
                Body:        requestBody,
                ContentType: aws.String("application/json"),
                Accept:      aws.String("application/json"),
        }

        result, err := p.bedrockClient.InvokeModelWithContext(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("Bedrock API call failed: %w", err)
        }</span>

        // Parse response using appropriate model handler
        <span class="cov0" title="0">text, tokensUsed, err := p.modelHandler.ParseResponse(result.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">response := &amp;CompletionResponse{
                Text:       text,
                TokensUsed: tokensUsed,
                Model:      p.config.ModelID,
                Provider:   ProviderBedrock,
                Metadata: map[string]string{
                        "model_family": p.modelHandler.GetModelFamily(),
                        "region":       p.config.Region,
                },
        }

        return response, nil</span>
}

// ValidateConfig validates the Bedrock provider configuration
func (p *BedrockProvider) ValidateConfig() error <span class="cov0" title="0">{
        if p.config.ModelID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("model ID is required")
        }</span>

        <span class="cov0" title="0">if p.config.Region == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("region is required")
        }</span>

        // Validate model ID format
        <span class="cov0" title="0">if !strings.Contains(p.config.ModelID, ".") </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid model ID format: %s", p.config.ModelID)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetProviderName returns the provider name
func (p *BedrockProvider) GetProviderName() Provider <span class="cov0" title="0">{
        return ProviderBedrock
}</span>

// getModelHandler returns the appropriate model handler based on model ID
func getModelHandler(modelID string) (BedrockModelHandler, error) <span class="cov0" title="0">{
        modelID = strings.ToLower(modelID)

        if strings.Contains(modelID, "claude") </span><span class="cov0" title="0">{
                return &amp;Claude3Handler{}, nil
        }</span> else<span class="cov0" title="0"> if strings.Contains(modelID, "titan") || strings.Contains(modelID, "j2") </span><span class="cov0" title="0">{
                return &amp;TitanHandler{}, nil
        }</span> else<span class="cov0" title="0"> if strings.Contains(modelID, "llama") </span><span class="cov0" title="0">{
                return &amp;LlamaHandler{}, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("unsupported model family for model ID: %s", modelID)</span>
}

// Claude3Handler implementation
func (h *Claude3Handler) PrepareRequest(prompt string, maxTokens int, temperature float32) ([]byte, error) <span class="cov0" title="0">{
        req := Claude3Request{
                Messages: []Claude3Message{
                        {
                                Role:    "user",
                                Content: prompt,
                        },
                },
                MaxTokens:   maxTokens,
                Temperature: temperature,
        }

        return json.Marshal(req)
}</span>

func (h *Claude3Handler) ParseResponse(response []byte) (string, int, error) <span class="cov0" title="0">{
        var resp Claude3Response
        if err := json.Unmarshal(response, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>

        <span class="cov0" title="0">if len(resp.Content) == 0 </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("no content in response")
        }</span>

        <span class="cov0" title="0">text := resp.Content[0].Text
        tokens := resp.Usage.InputTokens + resp.Usage.OutputTokens

        return text, tokens, nil</span>
}

func (h *Claude3Handler) GetModelFamily() string <span class="cov0" title="0">{
        return "claude"
}</span>

// TitanHandler implementation
func (h *TitanHandler) PrepareRequest(prompt string, maxTokens int, temperature float32) ([]byte, error) <span class="cov0" title="0">{
        req := TitanRequest{
                InputText: prompt,
                TextGenerationConfig: TitanGenConfig{
                        MaxTokenCount: maxTokens,
                        Temperature:   temperature,
                        TopP:          0.9,
                },
        }

        return json.Marshal(req)
}</span>

func (h *TitanHandler) ParseResponse(response []byte) (string, int, error) <span class="cov0" title="0">{
        var resp TitanResponse
        if err := json.Unmarshal(response, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>

        <span class="cov0" title="0">if len(resp.Results) == 0 </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("no results in response")
        }</span>

        <span class="cov0" title="0">text := resp.Results[0].OutputText
        tokens := resp.InputTextTokenCount + resp.Results[0].TokenCount

        return text, tokens, nil</span>
}

func (h *TitanHandler) GetModelFamily() string <span class="cov0" title="0">{
        return "titan"
}</span>

// LlamaHandler implementation
func (h *LlamaHandler) PrepareRequest(prompt string, maxTokens int, temperature float32) ([]byte, error) <span class="cov0" title="0">{
        req := LlamaRequest{
                Prompt:      prompt,
                MaxGenLen:   maxTokens,
                Temperature: temperature,
        }

        return json.Marshal(req)
}</span>

func (h *LlamaHandler) ParseResponse(response []byte) (string, int, error) <span class="cov0" title="0">{
        var resp LlamaResponse
        if err := json.Unmarshal(response, &amp;resp); err != nil </span><span class="cov0" title="0">{
                return "", 0, err
        }</span>

        <span class="cov0" title="0">text := resp.Generation
        tokens := resp.PromptTokenCount + resp.GenerationTokenCount

        return text, tokens, nil</span>
}

func (h *LlamaHandler) GetModelFamily() string <span class="cov0" title="0">{
        return "llama"
}</pre>
		
		<pre class="file" id="file5" style="display: none">package llm

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"

        "github.com/sirupsen/logrus"
)

// OpenAIProvider implements LLMProvider for OpenAI-compatible APIs
type OpenAIProvider struct {
        config     OpenAIConfig
        httpClient *http.Client
        baseURL    string
}

// OpenAIRequest represents the request format for OpenAI-compatible APIs
type OpenAIRequest struct {
        Model       string            `json:"model"`
        Messages    []OpenAIMessage   `json:"messages"`
        MaxTokens   int               `json:"max_tokens,omitempty"`
        Temperature float32           `json:"temperature,omitempty"`
        Stream      bool              `json:"stream"`
}

// OpenAIMessage represents a message in the OpenAI format
type OpenAIMessage struct {
        Role    string `json:"role"`
        Content string `json:"content"`
}

// OpenAIResponse represents the response from OpenAI-compatible APIs
type OpenAIResponse struct {
        ID      string `json:"id"`
        Object  string `json:"object"`
        Created int64  `json:"created"`
        Model   string `json:"model"`
        Choices []struct {
                Index   int `json:"index"`
                Message struct {
                        Role    string `json:"role"`
                        Content string `json:"content"`
                } `json:"message"`
                FinishReason string `json:"finish_reason"`
        } `json:"choices"`
        Usage struct {
                PromptTokens     int `json:"prompt_tokens"`
                CompletionTokens int `json:"completion_tokens"`
                TotalTokens      int `json:"total_tokens"`
        } `json:"usage"`
}

// OpenAIErrorResponse represents error responses from OpenAI-compatible APIs
type OpenAIErrorResponse struct {
        Error struct {
                Message string `json:"message"`
                Type    string `json:"type"`
                Code    string `json:"code"`
        } `json:"error"`
}

// NewOpenAIProvider creates a new OpenAI-compatible provider
func NewOpenAIProvider(config OpenAIConfig) (*OpenAIProvider, error) <span class="cov8" title="1">{
        if config.APIKey == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("API key is required for OpenAI provider")
        }</span>

        <span class="cov8" title="1">if config.Model == "" </span><span class="cov0" title="0">{
                config.Model = "gpt-3.5-turbo" // Default model
        }</span>

        <span class="cov8" title="1">baseURL := config.BaseURL
        if baseURL == "" </span><span class="cov8" title="1">{
                baseURL = "https://api.openai.com/v1" // Default OpenAI URL
        }</span>

        // Ensure baseURL doesn't end with slash
        <span class="cov8" title="1">baseURL = strings.TrimSuffix(baseURL, "/")

        httpClient := &amp;http.Client{
                Timeout: 60 * time.Second,
        }

        return &amp;OpenAIProvider{
                config:     config,
                httpClient: httpClient,
                baseURL:    baseURL,
        }, nil</span>
}

// Complete implements the LLMProvider interface
func (p *OpenAIProvider) Complete(ctx context.Context, req CompletionRequest) (*CompletionResponse, error) <span class="cov0" title="0">{
        // Convert to OpenAI format
        openaiReq := OpenAIRequest{
                Model: p.config.Model,
                Messages: []OpenAIMessage{
                        {
                                Role:    "user",
                                Content: req.Prompt,
                        },
                },
                MaxTokens:   req.MaxTokens,
                Temperature: req.Temperature,
                Stream:      false,
        }

        // Marshal request
        reqBody, err := json.Marshal(openaiReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request: %w", err)
        }</span>

        // Create HTTP request
        <span class="cov0" title="0">httpReq, err := http.NewRequestWithContext(ctx, "POST", p.baseURL+"/chat/completions", bytes.NewBuffer(reqBody))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        // Set headers
        <span class="cov0" title="0">httpReq.Header.Set("Content-Type", "application/json")
        httpReq.Header.Set("Authorization", "Bearer "+p.config.APIKey)

        if p.config.OrgID != "" </span><span class="cov0" title="0">{
                httpReq.Header.Set("OpenAI-Organization", p.config.OrgID)
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "url":    httpReq.URL.String(),
                "model":  p.config.Model,
                "tokens": req.MaxTokens,
        }).Debug("Sending request to OpenAI-compatible API")

        // Send request
        resp, err := p.httpClient.Do(httpReq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP request failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        // Read response
        respBody, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response body: %w", err)
        }</span>

        // Handle non-200 responses
        <span class="cov0" title="0">if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                var errorResp OpenAIErrorResponse
                if err := json.Unmarshal(respBody, &amp;errorResp); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("API request failed with status %d: %s", resp.StatusCode, string(respBody))
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("API error (%s): %s", errorResp.Error.Type, errorResp.Error.Message)</span>
        }

        // Parse successful response
        <span class="cov0" title="0">var openaiResp OpenAIResponse
        if err := json.Unmarshal(respBody, &amp;openaiResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>

        <span class="cov0" title="0">if len(openaiResp.Choices) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no choices in response")
        }</span>

        // Convert to our response format
        <span class="cov0" title="0">response := &amp;CompletionResponse{
                Text:       openaiResp.Choices[0].Message.Content,
                TokensUsed: openaiResp.Usage.TotalTokens,
                Model:      openaiResp.Model,
                Provider:   ProviderOpenAI,
                Metadata: map[string]string{
                        "finish_reason":      openaiResp.Choices[0].FinishReason,
                        "prompt_tokens":      fmt.Sprintf("%d", openaiResp.Usage.PromptTokens),
                        "completion_tokens":  fmt.Sprintf("%d", openaiResp.Usage.CompletionTokens),
                        "id":                 openaiResp.ID,
                },
        }

        return response, nil</span>
}

// ValidateConfig validates the OpenAI provider configuration
func (p *OpenAIProvider) ValidateConfig() error <span class="cov8" title="1">{
        if p.config.APIKey == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("API key is required")
        }</span>

        <span class="cov8" title="1">if p.config.Model == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("model is required")
        }</span>

        // Validate base URL format if provided
        <span class="cov8" title="1">if p.config.BaseURL != "" </span><span class="cov0" title="0">{
                if !strings.HasPrefix(p.config.BaseURL, "http://") &amp;&amp; !strings.HasPrefix(p.config.BaseURL, "https://") </span><span class="cov0" title="0">{
                        return fmt.Errorf("base URL must start with http:// or https://")
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// GetProviderName returns the provider name
func (p *OpenAIProvider) GetProviderName() Provider <span class="cov0" title="0">{
        // Determine actual provider based on base URL
        if strings.Contains(p.baseURL, "openai.com") </span><span class="cov0" title="0">{
                return ProviderOpenAI
        }</span> else<span class="cov0" title="0"> if strings.Contains(p.baseURL, "azure.com") </span><span class="cov0" title="0">{
                return ProviderAzure
        }</span> else<span class="cov0" title="0"> if strings.Contains(p.baseURL, "localhost") || strings.Contains(p.baseURL, "127.0.0.1") </span><span class="cov0" title="0">{
                return ProviderOllama
        }</span>
        <span class="cov0" title="0">return ProviderOpenAI</span> // Default
}</pre>
		
		<pre class="file" id="file6" style="display: none">package llm

import (
        "context"
        "fmt"
        "time"

        "github.com/sirupsen/logrus"
)

// Provider represents different LLM providers
type Provider string

const (
        ProviderOpenAI   Provider = "openai"
        ProviderBedrock  Provider = "bedrock"
        ProviderOllama   Provider = "ollama"
        ProviderAzure    Provider = "azure"
)

// Config holds LLM service configuration
type Config struct {
        Provider    Provider      `yaml:"provider" json:"provider"`
        Enabled     bool          `yaml:"enabled" json:"enabled"`
        Timeout     time.Duration `yaml:"timeout" json:"timeout"`
        MaxTokens   int           `yaml:"max_tokens" json:"max_tokens"`
        Temperature float32       `yaml:"temperature" json:"temperature"`

        // OpenAI-compatible configuration
        OpenAI OpenAIConfig `yaml:"openai" json:"openai"`

        // Bedrock configuration
        Bedrock BedrockConfig `yaml:"bedrock" json:"bedrock"`
}

// OpenAIConfig holds OpenAI-compatible API configuration
type OpenAIConfig struct {
        APIKey   string `yaml:"api_key" json:"api_key"`
        BaseURL  string `yaml:"base_url" json:"base_url"` // For OpenAI-compatible APIs
        Model    string `yaml:"model" json:"model"`
        OrgID    string `yaml:"org_id" json:"org_id"`
}

// BedrockConfig holds Amazon Bedrock configuration
type BedrockConfig struct {
        Region          string `yaml:"region" json:"region"`
        AccessKeyID     string `yaml:"access_key_id" json:"access_key_id"`
        SecretAccessKey string `yaml:"secret_access_key" json:"secret_access_key"`
        SessionToken    string `yaml:"session_token" json:"session_token"`
        RoleARN         string `yaml:"role_arn" json:"role_arn"`
        ModelID         string `yaml:"model_id" json:"model_id"`
}

// CompletionRequest represents a request for text completion
type CompletionRequest struct {
        Prompt      string            `json:"prompt"`
        MaxTokens   int               `json:"max_tokens,omitempty"`
        Temperature float32           `json:"temperature,omitempty"`
        Context     map[string]string `json:"context,omitempty"`
}

// CompletionResponse represents the response from LLM
type CompletionResponse struct {
        Text         string            `json:"text"`
        TokensUsed   int               `json:"tokens_used"`
        Model        string            `json:"model"`
        Provider     Provider          `json:"provider"`
        Metadata     map[string]string `json:"metadata,omitempty"`
}

// LLMProvider interface that all providers must implement
type LLMProvider interface {
        Complete(ctx context.Context, req CompletionRequest) (*CompletionResponse, error)
        ValidateConfig() error
        GetProviderName() Provider
}

// Service manages LLM operations
type Service struct {
        config   Config
        provider LLMProvider
}

// NewService creates a new LLM service with the specified configuration
func NewService(config Config) (*Service, error) <span class="cov8" title="1">{
        if !config.Enabled </span><span class="cov8" title="1">{
                return &amp;Service{config: config}, nil
        }</span>

        // Set defaults
        <span class="cov8" title="1">if config.Timeout == 0 </span><span class="cov8" title="1">{
                config.Timeout = 30 * time.Second
        }</span>
        <span class="cov8" title="1">if config.MaxTokens == 0 </span><span class="cov8" title="1">{
                config.MaxTokens = 1000
        }</span>
        <span class="cov8" title="1">if config.Temperature == 0 </span><span class="cov8" title="1">{
                config.Temperature = 0.7
        }</span>

        <span class="cov8" title="1">var provider LLMProvider
        var err error

        switch config.Provider </span>{
        case ProviderOpenAI, ProviderOllama, ProviderAzure:<span class="cov8" title="1">
                provider, err = NewOpenAIProvider(config.OpenAI)</span>
        case ProviderBedrock:<span class="cov0" title="0">
                provider, err = NewBedrockProvider(config.Bedrock)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported LLM provider: %s", config.Provider)</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create %s provider: %w", config.Provider, err)
        }</span>

        <span class="cov8" title="1">if err := provider.ValidateConfig(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid %s configuration: %w", config.Provider, err)
        }</span>

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "provider": config.Provider,
                "model":    getModelName(config),
                "timeout":  config.Timeout,
        }).Info("LLM service initialized")

        return &amp;Service{
                config:   config,
                provider: provider,
        }, nil</span>
}

// Complete performs text completion using the configured provider
func (s *Service) Complete(ctx context.Context, prompt string) (*CompletionResponse, error) <span class="cov8" title="1">{
        if !s.config.Enabled || s.provider == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("LLM service is disabled")
        }</span>

        // Create context with timeout
        <span class="cov8" title="1">timeoutCtx, cancel := context.WithTimeout(ctx, s.config.Timeout)
        defer cancel()

        req := CompletionRequest{
                Prompt:      prompt,
                MaxTokens:   s.config.MaxTokens,
                Temperature: s.config.Temperature,
        }

        logrus.WithFields(logrus.Fields{
                "provider":    s.provider.GetProviderName(),
                "prompt_len":  len(prompt),
                "max_tokens":  req.MaxTokens,
                "temperature": req.Temperature,
        }).Debug("Sending completion request to LLM")

        response, err := s.provider.Complete(timeoutCtx, req)
        if err != nil </span><span class="cov8" title="1">{
                logrus.WithFields(logrus.Fields{
                        "provider": s.provider.GetProviderName(),
                        "error":    err,
                }).Error("LLM completion failed")
                return nil, err
        }</span>

        <span class="cov8" title="1">logrus.WithFields(logrus.Fields{
                "provider":    response.Provider,
                "tokens_used": response.TokensUsed,
                "model":       response.Model,
                "response_len": len(response.Text),
        }).Debug("LLM completion successful")

        return response, nil</span>
}

// IsEnabled returns whether the LLM service is enabled
func (s *Service) IsEnabled() bool <span class="cov8" title="1">{
        return s.config.Enabled &amp;&amp; s.provider != nil
}</span>

// GetConfig returns the current configuration (with sensitive data masked)
func (s *Service) GetConfig() Config <span class="cov8" title="1">{
        config := s.config
        // Mask sensitive information
        config.OpenAI.APIKey = maskString(config.OpenAI.APIKey)
        config.Bedrock.AccessKeyID = maskString(config.Bedrock.AccessKeyID)
        config.Bedrock.SecretAccessKey = maskString(config.Bedrock.SecretAccessKey)
        config.Bedrock.SessionToken = maskString(config.Bedrock.SessionToken)
        return config
}</span>

// getModelName returns the model name based on provider
func getModelName(config Config) string <span class="cov8" title="1">{
        switch config.Provider </span>{
        case ProviderOpenAI, ProviderOllama, ProviderAzure:<span class="cov8" title="1">
                return config.OpenAI.Model</span>
        case ProviderBedrock:<span class="cov8" title="1">
                return config.Bedrock.ModelID</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// maskString masks sensitive strings for logging
func maskString(s string) string <span class="cov8" title="1">{
        if len(s) &lt;= 4 </span><span class="cov8" title="1">{
                return "****"
        }</span>
        <span class="cov8" title="1">return s[:2] + "****" + s[len(s)-2:]</span>
}</pre>
		
		<pre class="file" id="file7" style="display: none">package llm

import (
        "context"
        "fmt"
        "strings"

        "github.com/sirupsen/logrus"

        "dws/engine"
)

// SmartAnalyzer optimizes LLM usage by using rules as pre-filters
type SmartAnalyzer struct {
        analyzer *Analyzer
        config   SmartAnalysisConfig
}

// SmartAnalysisConfig controls when LLM analysis is triggered
type SmartAnalysisConfig struct {
        // Only use LLM if regex finds at least this many findings
        MinFindingsThreshold int `yaml:"min_findings_threshold"`

        // Only use LLM for these severity levels
        TriggerSeverities []string `yaml:"trigger_severities"`

        // Skip LLM for documents shorter than this
        MinDocumentLength int `yaml:"min_document_length"`

        // Maximum document length to send to LLM (token limit)
        MaxDocumentLength int `yaml:"max_document_length"`

        // Only analyze these rule categories with LLM
        AnalyzeRuleTypes []string `yaml:"analyze_rule_types"`

        // Skip LLM if confidence in regex results is high
        SkipIfHighConfidence bool `yaml:"skip_if_high_confidence"`
}

// SmartAnalysisResult combines regex pre-filtering with selective LLM usage
type SmartAnalysisResult struct {
        RegexFindings    []engine.Finding `json:"regex_findings"`
        LLMUsed          bool             `json:"llm_used"`
        LLMFindings      []LLMFinding     `json:"llm_findings,omitempty"`
        ValidatedFindings []engine.Finding `json:"validated_findings"`
        TokensUsed       int              `json:"tokens_used"`
        CostSavings      string           `json:"cost_savings,omitempty"`
        AnalysisReason   string           `json:"analysis_reason"`
}

// NewSmartAnalyzer creates an analyzer that uses rules to optimize LLM usage
func NewSmartAnalyzer(analyzer *Analyzer, config SmartAnalysisConfig) *SmartAnalyzer <span class="cov0" title="0">{
        // Set sensible defaults
        if config.MinFindingsThreshold == 0 </span><span class="cov0" title="0">{
                config.MinFindingsThreshold = 1
        }</span>
        <span class="cov0" title="0">if len(config.TriggerSeverities) == 0 </span><span class="cov0" title="0">{
                config.TriggerSeverities = []string{"high", "medium"}
        }</span>
        <span class="cov0" title="0">if config.MinDocumentLength == 0 </span><span class="cov0" title="0">{
                config.MinDocumentLength = 100
        }</span>
        <span class="cov0" title="0">if config.MaxDocumentLength == 0 </span><span class="cov0" title="0">{
                config.MaxDocumentLength = 8000 // ~3000 tokens
        }</span>

        <span class="cov0" title="0">return &amp;SmartAnalyzer{
                analyzer: analyzer,
                config:   config,
        }</span>
}

// AnalyzeWithPrefiltering performs intelligent analysis using rules as filters
func (s *SmartAnalyzer) AnalyzeWithPrefiltering(ctx context.Context, text, filename string, rules []engine.Rule) (*SmartAnalysisResult, error) <span class="cov0" title="0">{
        result := &amp;SmartAnalysisResult{
                RegexFindings: []engine.Finding{},
                LLMUsed:       false,
                TokensUsed:    0,
        }

        // Step 1: Always run regex analysis first (fast and cheap)
        regexFindings := engine.Evaluate(text, filename, rules)
        result.RegexFindings = regexFindings

        logrus.WithFields(logrus.Fields{
                "filename":      filename,
                "regex_findings": len(regexFindings),
                "doc_length":    len(text),
        }).Debug("Regex pre-filtering complete")

        // Step 2: Decide if LLM analysis is warranted
        shouldUseLLM, reason := s.shouldUseLLM(text, regexFindings)
        result.AnalysisReason = reason

        if !shouldUseLLM </span><span class="cov0" title="0">{
                result.ValidatedFindings = regexFindings
                result.CostSavings = "100% - LLM not needed"
                logrus.WithFields(logrus.Fields{
                        "filename": filename,
                        "reason":   reason,
                }).Info("Skipping LLM analysis")
                return result, nil
        }</span>

        // Step 3: Use LLM for validation/enhancement
        <span class="cov0" title="0">if s.analyzer != nil &amp;&amp; s.analyzer.service != nil &amp;&amp; s.analyzer.service.IsEnabled() </span><span class="cov0" title="0">{
                result.LLMUsed = true

                // Truncate document if too long
                analysisText := s.prepareTextForLLM(text)

                // Create focused analysis request based on regex findings
                analysisReq := s.createFocusedAnalysisRequest(analysisText, filename, regexFindings)

                llmResponse, err := s.analyzer.AnalyzeDocument(ctx, analysisReq)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.WithFields(logrus.Fields{
                                "filename": filename,
                                "error":    err,
                        }).Warn("LLM analysis failed, using regex results")
                        result.ValidatedFindings = regexFindings
                        return result, nil
                }</span>

                <span class="cov0" title="0">result.LLMFindings = llmResponse.Findings
                result.TokensUsed = llmResponse.TokensUsed

                // Validate regex findings with LLM
                validatedFindings, err := s.analyzer.ValidateFindings(ctx, regexFindings, analysisText, filename)
                if err != nil </span><span class="cov0" title="0">{
                        result.ValidatedFindings = regexFindings
                }</span> else<span class="cov0" title="0"> {
                        result.ValidatedFindings = validatedFindings
                }</span>

                // Calculate approximate cost savings
                <span class="cov0" title="0">fullDocTokens := len(text) / 4 // Rough token estimate
                actualTokens := result.TokensUsed
                if fullDocTokens &gt; actualTokens </span><span class="cov0" title="0">{
                        savings := float64(fullDocTokens-actualTokens) / float64(fullDocTokens) * 100
                        result.CostSavings = fmt.Sprintf("%.1f%% vs full document analysis", savings)
                }</span>
        } else<span class="cov0" title="0"> {
                result.ValidatedFindings = regexFindings
                result.CostSavings = "100% - LLM disabled"
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// shouldUseLLM determines if LLM analysis is warranted based on regex results
func (s *SmartAnalyzer) shouldUseLLM(text string, findings []engine.Finding) (bool, string) <span class="cov0" title="0">{
        // Check document length
        if len(text) &lt; s.config.MinDocumentLength </span><span class="cov0" title="0">{
                return false, fmt.Sprintf("Document too short (%d chars &lt; %d min)", len(text), s.config.MinDocumentLength)
        }</span>

        // Check if any findings meet threshold
        <span class="cov0" title="0">if len(findings) &lt; s.config.MinFindingsThreshold </span><span class="cov0" title="0">{
                return false, fmt.Sprintf("Insufficient findings (%d &lt; %d threshold)", len(findings), s.config.MinFindingsThreshold)
        }</span>

        // Check severity levels
        <span class="cov0" title="0">hasTargetSeverity := false
        for _, finding := range findings </span><span class="cov0" title="0">{
                for _, targetSeverity := range s.config.TriggerSeverities </span><span class="cov0" title="0">{
                        if strings.EqualFold(finding.Severity, targetSeverity) </span><span class="cov0" title="0">{
                                hasTargetSeverity = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if hasTargetSeverity </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if !hasTargetSeverity </span><span class="cov0" title="0">{
                return false, fmt.Sprintf("No findings match target severities: %v", s.config.TriggerSeverities)
        }</span>

        // Check rule types (if configured)
        <span class="cov0" title="0">if len(s.config.AnalyzeRuleTypes) &gt; 0 </span><span class="cov0" title="0">{
                hasTargetRuleType := false
                for _, finding := range findings </span><span class="cov0" title="0">{
                        for _, targetType := range s.config.AnalyzeRuleTypes </span><span class="cov0" title="0">{
                                if strings.Contains(finding.RuleID, targetType) </span><span class="cov0" title="0">{
                                        hasTargetRuleType = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if hasTargetRuleType </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !hasTargetRuleType </span><span class="cov0" title="0">{
                        return false, fmt.Sprintf("No findings match target rule types: %v", s.config.AnalyzeRuleTypes)
                }</span>
        }

        <span class="cov0" title="0">return true, fmt.Sprintf("LLM analysis triggered: %d findings with target severity", len(findings))</span>
}

// prepareTextForLLM truncates or focuses text for LLM analysis
func (s *SmartAnalyzer) prepareTextForLLM(text string) string <span class="cov0" title="0">{
        if len(text) &lt;= s.config.MaxDocumentLength </span><span class="cov0" title="0">{
                return text
        }</span>

        // Truncate but try to keep complete sentences
        <span class="cov0" title="0">truncated := text[:s.config.MaxDocumentLength]

        // Find last complete sentence
        lastPeriod := strings.LastIndex(truncated, ".")
        lastNewline := strings.LastIndex(truncated, "\n")

        cutPoint := lastPeriod
        if lastNewline &gt; lastPeriod </span><span class="cov0" title="0">{
                cutPoint = lastNewline
        }</span>

        <span class="cov0" title="0">if cutPoint &gt; s.config.MaxDocumentLength/2 </span><span class="cov0" title="0">{
                truncated = truncated[:cutPoint+1]
        }</span>

        <span class="cov0" title="0">return truncated + "\n\n[Document truncated for analysis]"</span>
}

// createFocusedAnalysisRequest creates an LLM request focused on regex findings
func (s *SmartAnalyzer) createFocusedAnalysisRequest(text, filename string, findings []engine.Finding) AnalysisRequest <span class="cov0" title="0">{
        // Create focused rules based on what regex found
        var focusedRules []string

        ruleCategories := make(map[string]bool)
        for _, finding := range findings </span><span class="cov0" title="0">{
                // Extract category from rule ID (e.g., "disease-rabies" -&gt; "disease")
                parts := strings.Split(finding.RuleID, "-")
                if len(parts) &gt; 0 </span><span class="cov0" title="0">{
                        category := parts[0]
                        if !ruleCategories[category] </span><span class="cov0" title="0">{
                                ruleCategories[category] = true

                                // Map categories to focused prompts
                                switch category </span>{
                                case "disease":<span class="cov0" title="0">
                                        focusedRules = append(focusedRules, "Validate disease symptoms and assess public health risk severity")</span>
                                case "aggressive":<span class="cov0" title="0">
                                        focusedRules = append(focusedRules, "Analyze behavioral context - distinguish defensive vs truly aggressive behavior")</span>
                                case "property":<span class="cov0" title="0">
                                        focusedRules = append(focusedRules, "Assess property damage severity and determine intervention level needed")</span>
                                case "parasite":<span class="cov0" title="0">
                                        focusedRules = append(focusedRules, "Evaluate parasite exposure risk and contamination concerns")</span>
                                default:<span class="cov0" title="0">
                                        focusedRules = append(focusedRules, fmt.Sprintf("Analyze and validate %s-related findings", category))</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">if len(focusedRules) == 0 </span><span class="cov0" title="0">{
                focusedRules = []string{"Validate and provide context for the flagged content"}
        }</span>

        <span class="cov0" title="0">return AnalysisRequest{
                Text:     text,
                Filename: filename,
                Rules:    focusedRules,
                Context:  fmt.Sprintf("Focus on validating %d regex findings", len(findings)),
        }</span>
}

// GetOptimizationStats returns statistics about LLM usage optimization
func (s *SmartAnalyzer) GetOptimizationStats() map[string]interface{} <span class="cov0" title="0">{
        return map[string]interface{}{
                "config": s.config,
                "optimization_strategies": []string{
                        "Document length filtering",
                        "Findings threshold gating",
                        "Severity-based triggering",
                        "Rule category focusing",
                        "Text truncation for large documents",
                },
        }
}</pre>
		
		<pre class="file" id="file8" style="display: none">package main

import (
        "fmt"
        "net/http"
        "os"
        "time"

        "github.com/sirupsen/logrus"
        "gopkg.in/yaml.v3"

        "dws/api"
        "dws/engine"
        "dws/llm"
)

var debugMode bool

func initLogging() <span class="cov0" title="0">{
        logOutput := os.Getenv("LOGGING")
        if logOutput == "stdout" </span><span class="cov0" title="0">{
                logrus.SetOutput(os.Stdout)
        }</span> else<span class="cov0" title="0"> if logOutput == "file" </span><span class="cov0" title="0">{
                logFile, err := os.OpenFile("dws.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
                if err != nil </span><span class="cov0" title="0">{
                        logrus.Fatalf("Failed to open log file: %v", err)
                }</span>
                <span class="cov0" title="0">logrus.SetOutput(logFile)</span>
        } else<span class="cov0" title="0"> {
                // Default to stderr
                logrus.SetOutput(os.Stderr)
        }</span>

        <span class="cov0" title="0">logrus.SetFormatter(&amp;logrus.JSONFormatter{})

        debugEnv := os.Getenv("DEBUG")
        if debugEnv == "true" </span><span class="cov0" title="0">{
                debugMode = true
                logrus.SetLevel(logrus.DebugLevel)
        }</span>
        <span class="cov0" title="0">logrus.Printf("DEBUG_MODE: %t", debugMode)</span>
}

func NewServer(rulesFile string) (*http.Server, error) <span class="cov8" title="1">{
        if rulesFile != "" </span><span class="cov8" title="1">{
                if err := engine.LoadRulesFromYAML(rulesFile); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("failed to load rules from %s: %w", rulesFile, err)
                }</span>
        }

        // Initialize LLM service
        <span class="cov8" title="1">llmService, err := initLLMService()
        if err != nil </span><span class="cov0" title="0">{
                logrus.WithError(err).Warn("Failed to initialize LLM service, LLM features will be disabled")
        }</span> else<span class="cov8" title="1"> if llmService != nil &amp;&amp; llmService.IsEnabled() </span><span class="cov0" title="0">{
                analyzer := llm.NewAnalyzer(llmService)
                api.SetLLMAnalyzer(analyzer)
                logrus.Info("LLM service initialized successfully")
        }</span> else<span class="cov8" title="1"> {
                logrus.Info("LLM service disabled")
        }</span>

        <span class="cov8" title="1">port := os.Getenv("PORT")
        if port == "" </span><span class="cov8" title="1">{
                port = "8080" // Default port to match Docker/K8s configs
        }</span>
        
        <span class="cov8" title="1">recoveryMiddleware := func(handler http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        defer func() </span><span class="cov8" title="1">{
                                if err := recover(); err != nil </span><span class="cov0" title="0">{
                                        logrus.WithFields(logrus.Fields{
                                                "error": err,
                                                "url":   r.URL.Path,
                                                "method": r.Method,
                                                "user_agent": r.UserAgent(),
                                        }).Error("HTTP handler panic recovered")
                                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                                }</span>
                        }()
                        <span class="cov8" title="1">handler.ServeHTTP(w, r)</span>
                })
        }

        <span class="cov8" title="1">mux := http.NewServeMux()
        mux.HandleFunc("/scan", api.ScanHandler)
        mux.HandleFunc("/scan/s3", api.S3ScanHandler)
        mux.HandleFunc("/scan/llm", api.LLMScanHandler)
        mux.HandleFunc("/scan/hybrid", api.HybridScanHandler)
        mux.HandleFunc("/scan/smart", api.SmartScanHandler)
        mux.HandleFunc("/rules/reload", api.ReloadRulesHandler)
        mux.HandleFunc("/rules/load", api.LoadRulesFromFileHandler)
        mux.HandleFunc("/ruleset", api.RulesetHandler)
        mux.HandleFunc("/health", api.HealthHandler)
        mux.HandleFunc("/docs", api.DocsHandler)
        return &amp;http.Server{Addr: ":" + port, Handler: recoveryMiddleware(mux)}, nil</span>
}

// initLLMService initializes the LLM service from configuration
func initLLMService() (*llm.Service, error) <span class="cov8" title="1">{
        // Check if LLM is enabled via environment variable
        if enabled := os.Getenv("LLM_ENABLED"); enabled != "true" </span><span class="cov8" title="1">{
                return nil, nil // LLM disabled
        }</span>

        // Load LLM configuration
        <span class="cov0" title="0">configFile := os.Getenv("LLM_CONFIG")
        if configFile == "" </span><span class="cov0" title="0">{
                configFile = "config/llm.yaml" // Default LLM config
        }</span>

        // Check if config file exists
        <span class="cov0" title="0">if _, err := os.Stat(configFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("LLM config file not found: %s", configFile)
        }</span>

        // Read and parse config
        <span class="cov0" title="0">data, err := os.ReadFile(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read LLM config: %w", err)
        }</span>

        <span class="cov0" title="0">var config struct {
                LLM     llm.Config      `yaml:"llm"`
                OpenAI  llm.OpenAIConfig  `yaml:"openai"`
                Bedrock llm.BedrockConfig `yaml:"bedrock"`
        }

        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse LLM config: %w", err)
        }</span>

        // Set provider-specific configs
        <span class="cov0" title="0">config.LLM.OpenAI = config.OpenAI
        config.LLM.Bedrock = config.Bedrock

        // Expand environment variables in sensitive fields
        config.LLM.OpenAI.APIKey = os.ExpandEnv(config.LLM.OpenAI.APIKey)
        config.LLM.Bedrock.AccessKeyID = os.ExpandEnv(config.LLM.Bedrock.AccessKeyID)
        config.LLM.Bedrock.SecretAccessKey = os.ExpandEnv(config.LLM.Bedrock.SecretAccessKey)
        config.LLM.Bedrock.SessionToken = os.ExpandEnv(config.LLM.Bedrock.SessionToken)
        config.LLM.Bedrock.RoleARN = os.ExpandEnv(config.LLM.Bedrock.RoleARN)

        // Parse timeout
        if config.LLM.Timeout == 0 </span><span class="cov0" title="0">{
                config.LLM.Timeout = 30 * time.Second
        }</span>

        // Create LLM service
        <span class="cov0" title="0">service, err := llm.NewService(config.LLM)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create LLM service: %w", err)
        }</span>

        <span class="cov0" title="0">return service, nil</span>
}

func run() error <span class="cov0" title="0">{
        rulesFile := os.Getenv("RULES_FILE")
        if rulesFile == "" </span><span class="cov0" title="0">{
                rulesFile = "config/default.yaml" // Default rules file
        }</span>
        <span class="cov0" title="0">api.SetRulesFile(rulesFile)
        srv, err := NewServer(rulesFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return srv.ListenAndServe()</span>
}

func main() <span class="cov0" title="0">{
        initLogging()
        engine.SetDebugMode(debugMode)

        if err := run(); err != nil </span><span class="cov0" title="0">{
                logrus.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package s3

import (
        "context"
        "fmt"
        "net/http"
        "net/url"
        "strings"
        "time"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/awserr"
        "github.com/aws/aws-sdk-go/aws/credentials"
        "github.com/aws/aws-sdk-go/aws/credentials/stscreds"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/s3"
        "github.com/aws/aws-sdk-go/service/s3/s3manager"
        "github.com/sirupsen/logrus"
)

// Client wraps the S3 client with convenience methods
type Client struct {
        s3Client   *s3.S3
        downloader *s3manager.Downloader
}

// Config holds S3 client configuration
type Config struct {
        Region          string
        AccessKeyID     string
        SecretAccessKey string
        SessionToken    string
        RoleARN         string
        Timeout         time.Duration
}

// NewClient creates a new S3 client with the provided configuration
func NewClient(config Config) (*Client, error) <span class="cov8" title="1">{
        // Set default timeout if not specified
        if config.Timeout == 0 </span><span class="cov8" title="1">{
                config.Timeout = 30 * time.Second
        }</span>

        <span class="cov8" title="1">awsConfig := &amp;aws.Config{
                Region:     aws.String(config.Region),
                HTTPClient: &amp;http.Client{Timeout: config.Timeout},
                MaxRetries: aws.Int(3), // Add retry logic
        }

        // Configure credentials based on what's provided
        var sess *session.Session
        var err error

        if config.RoleARN != "" </span><span class="cov8" title="1">{
                // Use IAM role
                sess, err = session.NewSession(awsConfig)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">creds := stscreds.NewCredentials(sess, config.RoleARN)
                awsConfig.Credentials = creds</span>
        } else<span class="cov8" title="1"> if config.AccessKeyID != "" &amp;&amp; config.SecretAccessKey != "" </span><span class="cov8" title="1">{
                // Use access keys
                creds := credentials.NewStaticCredentials(config.AccessKeyID, config.SecretAccessKey, config.SessionToken)
                awsConfig.Credentials = creds
        }</span>
        // If neither is provided, it will use the default credential chain (environment variables, IAM role, etc.)

        <span class="cov8" title="1">sess, err = session.NewSession(awsConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">s3Client := s3.New(sess)
        downloader := s3manager.NewDownloader(sess)

        return &amp;Client{
                s3Client:   s3Client,
                downloader: downloader,
        }, nil</span>
}

// ParseS3URL parses an S3 URL and returns bucket and key
func ParseS3URL(s3URL string) (bucket, key string, err error) <span class="cov8" title="1">{
        u, err := url.Parse(s3URL)
        if err != nil </span><span class="cov0" title="0">{
                return "", "", err
        }</span>

        <span class="cov8" title="1">if u.Scheme != "s3" </span><span class="cov8" title="1">{
                return "", "", fmt.Errorf("invalid S3 URL scheme: %s", u.Scheme)
        }</span>

        <span class="cov8" title="1">bucket = u.Host
        key = strings.TrimPrefix(u.Path, "/")

        return bucket, key, nil</span>
}

// DownloadFile downloads a file from S3 and returns its contents
func (c *Client) DownloadFile(ctx context.Context, bucket, key string) ([]byte, error) <span class="cov0" title="0">{
        logrus.WithFields(logrus.Fields{
                "bucket": bucket,
                "key":    key,
        }).Info("Downloading file from S3")

        buf := aws.NewWriteAtBuffer([]byte{})

        // Create a context with timeout
        downloadCtx, cancel := context.WithTimeout(ctx, 5*time.Minute)
        defer cancel()

        _, err := c.downloader.DownloadWithContext(downloadCtx, buf, &amp;s3.GetObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })

        if err != nil </span><span class="cov0" title="0">{
                logrus.WithFields(logrus.Fields{
                        "bucket": bucket,
                        "key":    key,
                        "error":  err,
                }).Error("Failed to download file from S3")
                return nil, err
        }</span>

        <span class="cov0" title="0">logrus.WithFields(logrus.Fields{
                "bucket": bucket,
                "key":    key,
                "size":   len(buf.Bytes()),
        }).Info("Successfully downloaded file from S3")

        return buf.Bytes(), nil</span>
}

// DownloadFileFromURL downloads a file from S3 using a full S3 URL
func (c *Client) DownloadFileFromURL(ctx context.Context, s3URL string) ([]byte, string, error) <span class="cov8" title="1">{
        bucket, key, err := ParseS3URL(s3URL)
        if err != nil </span><span class="cov8" title="1">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">data, err := c.DownloadFile(ctx, bucket, key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">return data, key, nil</span>
}

// CheckFileExists checks if a file exists in S3
func (c *Client) CheckFileExists(ctx context.Context, bucket, key string) (bool, error) <span class="cov0" title="0">{
        _, err := c.s3Client.HeadObjectWithContext(ctx, &amp;s3.HeadObjectInput{
                Bucket: aws.String(bucket),
                Key:    aws.String(key),
        })

        if err != nil </span><span class="cov0" title="0">{
                if aerr, ok := err.(awserr.Error); ok </span><span class="cov0" title="0">{
                        switch aerr.Code() </span>{
                        case s3.ErrCodeNoSuchKey, "NotFound":<span class="cov0" title="0">
                                return false, nil</span>
                        }
                }
                <span class="cov0" title="0">return false, err</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package scanner

import (
        "fmt"
        "path/filepath"
        "strings"
)

// ExtractText extracts text from various file formats
func ExtractText(data []byte, filename string) (string, error) <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(filename))

        switch ext </span>{
        case ".pdf":<span class="cov0" title="0">
                return extractPDFText(data)</span>
        case ".txt":<span class="cov8" title="1">
                return string(data), nil</span>
        case ".html", ".htm":<span class="cov8" title="1">
                return extractHTMLText(data)</span>
        case "":<span class="cov8" title="1">
                // No extension - try to extract as text
                return string(data), nil</span>
        default:<span class="cov8" title="1">
                // Check if it looks like binary data
                if isBinaryData(data) </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("unsupported file format: %s", ext)
                }</span>
                // Try to extract as plain text for unknown text-like formats
                <span class="cov8" title="1">return string(data), nil</span>
        }
}

// isBinaryData performs a basic check to see if data is likely binary
func isBinaryData(data []byte) bool <span class="cov8" title="1">{
        // Check first 512 bytes for null bytes which are common in binary files
        for i, b := range data </span><span class="cov8" title="1">{
                if i &gt; 512 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">if b == 0 </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if i &gt;= 3 </span><span class="cov8" title="1">{
                        // Check for PNG signature (89 PNG)
                        if len(data) &gt;= 4 </span><span class="cov8" title="1">{
                                prefix := data[:4]
                                if prefix[0] == 0x89 &amp;&amp; prefix[1] == 0x50 &amp;&amp; prefix[2] == 0x4E &amp;&amp; prefix[3] == 0x47 </span><span class="cov8" title="1">{
                                        return true
                                }</span>
                        }
                }
                <span class="cov8" title="1">if i &gt;= 1 </span><span class="cov8" title="1">{
                        // Check for BMP signature (BM)
                        if len(data) &gt;= 2 </span><span class="cov8" title="1">{
                                prefix := data[:2]
                                if prefix[0] == 0x42 &amp;&amp; prefix[1] == 0x4D </span><span class="cov8" title="1">{
                                        return true
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return false</span>
}

// extractPDFText extracts text from PDF files
func extractPDFText(data []byte) (string, error) <span class="cov0" title="0">{
        // TODO: Implement PDF text extraction
        // For now, return a placeholder
        return "PDF text extraction not implemented", nil
}</span>

// extractHTMLText extracts text from HTML files
func extractHTMLText(data []byte) (string, error) <span class="cov8" title="1">{
        html := string(data)

        // Simple HTML-to-text conversion (very basic)
        // Remove HTML tags
        text := strings.ReplaceAll(html, "&lt;script&gt;", "")
        text = strings.ReplaceAll(text, "&lt;/script&gt;", "")
        text = strings.ReplaceAll(text, "&lt;style&gt;", "")
        text = strings.ReplaceAll(text, "&lt;/style&gt;", "")

        // Basic tag removal
        start := strings.Index(text, "&lt;")
        for start != -1 </span><span class="cov8" title="1">{
                end := strings.Index(text[start:], "&gt;")
                if end == -1 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">text = text[:start] + text[start+end+1:]
                start = strings.Index(text, "&lt;")</span>
        }

        // TODO: Decode HTML entities later if needed
        // Currently using basic extraction

        <span class="cov8" title="1">return strings.TrimSpace(text), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
